변수는 값의 위치(주소)를 기억하는 저장소이다. 값의 위치란 값이 위치하고 있는 메모리 상의 주소 를 의미한다. 즉, 변수란 값이 위치하고 있는 메모리 주소 에 접근하기 위해 사람이 이해 할 수 있는 언어로 명명한 식별자 이다.

자바스크립트는 동적타입(Dynamic/Weak Type)언어이다. 변수 타입 지정 없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정(타입추론, Type Inference)된다. 즉, 변수는 고정된 타입이 없다. 따라서 변수의 여러 타입을 자유롭게 할당할 수 있다.

# 1. 데이터 타입

코드에서 사용되는 모든 데이터는 메모리에 저장하고 참조할 수 있어야 한다. 데이터 타입은 데이터를 메모리에 저장할 때 확보해야 하는 메모리 공간의 크기와 할당할 수 있는 유효한 값에 대한 정보, 그리고 메모리에 저장되어 있는 2진수 데이터를 어떻게 해석할 지에 대한 정보를 컴퓨터와 개발자에게 제공한다.

`7가지 데이터 타입`

- 원시 타입 (primitive data type)
  - boolean
  - null
  - undefined
  - number
  - string
  - symbol(ES6 추가)
- 객체타입(object/reference type)
  - object

# 1.1 원시 타입(Primitive Data Type)

원시 타입은 값은 ` 변경 불가능한 값(immutable value)` 며 pass-by-value(값에 의한 전달)이다.

## 1.1.1 number

ECMAScipt 표준에 따르면, 숫자 타입의 값은 배정밀도 63비트 부동소수점 형 을 따른다.
자바스크립트는 2진수,8진수,16진수 데이ㅓ 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수를 처리한다. 정수로 표시된다해도 사실은 실수다. 따라서 정수로 표시되는 수 끼리 나누더라도 실수가 나올수 있다.

3가지 특별한 값

- Infinity : 양의 무한대
- -Infinity : 음의 무한대
- NaN : 산술 연산 불가(not-a-number)

프로그래밍 언어에서 실수는 일반적으로 소수를 가리킨다.

## 1.1.2 string

문자열은 0개 이상의 16bit 유니코드 문자(UTF-16) 들의 집합으로 대부분의 전세계의 문자를 표현할 수 있다. 작은 따옴표 (' '), 또는 큰 따옴표(" ") 넣어 생성한다.

문자열은 원시 타입이며 변경 불가능 하다.

```js
var str = 'hello';
str = 'world';
```

첫번째 구문이 실행되면 메모리에 문자열 'hello'가 생성되고 식별자 str은 메모리에 생성된 문자열 'hello'의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 'hello'을 수정하는 것이 아니라 새로운 문자열 'world'를 메모리에 생서하고 식별자 str은 이것을 가리킨다. 이때 문자열 'hello'와 'world'는 모두 메모리에 존재하고 있다. 변수 str은 문자열 'Hello'를 가리키고 있다가 문자열 'world'를 가리키도록 변경되었을 뿐이다.

### 유사 배열

문자열은 배열처럼 인덱스를 통해 접근할 수 있다.

```js
var str = 'string';
for (var i = 0; i < str.length; i++) {
  console.log(str[i]);
}

str[0] = 'S'; // 문자열을 변경할 수 없다.
console.log(str); //string
```

`str[0] = 'S'` 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.(에러발생하지 않음) 한번 생성된 문자열은 `read only`로 변경할 수 없다. (immutable)
그러나 새로운 문자열을 재할당하는 것은 물론 가능하다.

```js
var str = 'string';
console.log(string); //string

str = 'String';
console.log(str); // String

str += ' test';
console.log(str); // String test

str = str.substing(0, 3);
console.log(str); // Str

str = str.toUpperCase();
console.log(str); //STR
```

## 1.1.3 boolean

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true/false 뿐이다.

분리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에 자주 사용 한다.

### false

- " "
- null
- undefined
- 0

## 1.1.4 undefined

undefine 타입의 값은 `undefined`가 유일하다. 선언ㄴ 이후 값을 할당하지 않은 변수는 `undefined`값 을 가진다. 즉, 선언은 되었지만 값을 할당하지 않은 변수가 접근하거나 존재하지 않은 객체 프로퍼티에 접근 할 경우 undefined가 반환된다.
이는 변수 선언데 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(Garbage value)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화하기 때문이다.
의도적으로 변수의 값에 undefined 를 할당하지 않는것이 좋다.

## 1.1.5 null

null 타입의 값은 `null` 이 유일하다. 대소문자를 구별하여 `null` 이 아니면 다르다.
프로그래밍 언어에서 null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 이는 변수가 기억하는 메모리 어드레스의 참조 정보를 제거하는 것을 의미하며 자바스크립트 엔진은 누구도 참조하지 않은 메모리 영여에 대해 가비지 콜렉션을 수행할 것이다.

함수가 호출되었으나 유효한 값을 변환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

```js
//  HTML 문서에 myElem 클래스를 갖는 요소가 없다면 null을 반환한다.
var element = document.querySelector('.myElem');
console.log(element); //null
```

typeof null 은 설계상 오류로 object를 반환한다.

```js
var foo = null;
console.log(typeof foo); //object
```

null 타입을 확인할 때 typeof 연산자 말고 일치연산자(===)를 사용한다.

```js
var foo = null;
console.log(typeof foo === null); //false
console.log(foo === null); //true
```

## 1.1.6 symbol

심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키 (property key)를 만들기 위해 사용한다. 심볼은 Symbol함수를 호출해 행성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.

```js
//심볼 key는
var key = symbol('key');
console.log(typeof key); //symbol

var obj = {};
obj[key] = 'value';
console.log(obj[key]); //value
```

# 1.2 객체 타입(Object type, Reference type)

이름과 값을 가지는 데이터를 의미한느 프로퍼티(property)와 동작을 의미하는 메소드(method)를 포함할 수 있는 독립적 주체이다.
자바스크립트는 객체(object)기반의 스크립트 언어로서 자바스크립트를 이루고 있는 거의 '모든 것'이 객체이다.
pass-by-reference(참조에 의한 전달)방식으로 전달

# 2. 변수

**식별자**

> 식별자는 어떤 대상을 유일하게 식별할 수 있는 이름을 말한다. 식별자에는 변수명, 함수명, 프로퍼티명, 클래스 명 등이 있다.

변수는 `var`, `let`, `const` 키워드를 사용하여 **선언**하고 할당 연산자를 사용해 값을 **할당**한다. 그리고 식별자인 변수명을 사용해 변수에 저장된 값을 참조한다.

```js
var score; // 변수의 선언
score = 80; //값의 할당
score = 90; // 값의 재할당
score; //변수의 참조

// 변수의 선언과 할당
var average = (50 + 100) / 2;
```

# 2.1 변수의 선언

> 변수를 사용하여 데이터를 기억(캐싱)하고 기억된 데이터를 재사용 할수 있다.
> 변수명은 식별자(identifier)로 불리기도 하며 명명 규칙이 존재한다.

- 반드시 영문자(특수문자 제외), underscore(\_), 또는 달러 기회($)로 시작하여야 한다. 이어지는 문자에는 숫자(0~9)도 사용 할수 있다.
- 자바스크립트는 대/소문자를 구별하므로 사용할 수 있는 문자는 "A ~ Z" "a ~ z" 대문자와 소문자 이다.

값을 할당하지 않은 변수는 undefined로 초기값을 갖는다. 선언하지 않는 변수에 접근하면 ReferenceError가 발생한다.

# 2.1 변수의 중복 선언

var 키워드로 선언한 변수는 중복 선언이 가능하다. 그러나 동일한 변수명이 선언되어 있는 것을 모르고 변수를 중복 선언했다면 의도지 않게 변수의 값을 변경하는 부작용을 발생시킬수 있다. 따라서 변수의 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다.

# 2.2 동적 타이핑 (Dynamic Typing)

변수의 타입 지정 없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결정 되는 것을 말한다.
따라서 같은 변수에 여러 타입의 값을 할당할 수 있다.

# 2.3 변수 호이스팅(Variable Hoisting)

```js
console.log(foo); //undefined
var foo = 123;
console.log(foo); // 123
{
  var foo = 456;
}
console.log(foo); // 456
```

var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다.
즉, 자바스크립트는 모든 선언문(var,let,const,function,class)이 선언되기 이전에 참조 가능하다.

변수 생성 과정

> **선언 단계(Declaration phase)**
> 변수 객체 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이된다.
> **초기화 단계(Initialization phase)**
> 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화 된다.
> **할당 단계(Assignment phase)**
> undefined로 초기화된 변수에 실제값을 할당한다.

**hoistiong**

> var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 즉, 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 variable object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅 이라고 한다.

### 함수 레벨 스코프와 블록 레벨 스코프

> 함수 레벨 스코프
> 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.
> 즉 함수 내부에서 선언한 변수는 지역 변수이며 외부에서 선언한한 변수는 모두 전역 변수이다.
> 블록 레벨 스코프
> 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

# 2.4 var 키워드로 선언된 변수의 문제점

1. 함수 레벨 스코프

- 전역 변수의 남발
- for loop 초기화식에서 사용한 변수를 for loop 외부 전역에서 참조할 수 있다.

2. var 키워드 생략 허용

- 의도하지 않은 변수의 전역화

3. 중복 선언 허용

- 의도하지 않은 변수값 변경

4. 변수 호이스팅

- 변수를 선언하기 전에 참조가 가능하다.

전역 변수는 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될 지 파악하기 힘들다. 이는 의도치 않은 변수의 변경이 발생할 수 있는 가능성이 증가한다. 또한 여러 함수와 상호의존하는 등 부수효과(side Effect)가 있을 수 있어서 복잡성이 증가한다.
변수의 유효 범위는 좁을 수록 좋다.
이를 보안하기 위해 ES6는 이러한 var의 단점을 보완하기 위해 let과 const 키워드를 도입하였다.

<div align="center">
<img src="https://poiemaweb.com/img/memory_address.png" width="50%" height="50%">
<div>

   
**변수**란 값이 위치하고 있는 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 명명한 식별자를 말함

자바스크립트는 동적 타입 언어임
변수의 타입 지정 없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정(타입 추론, Type Inference)됌
정리하자면 변수는 고정된 타입이 없다. 따라서 같은 변수에 여러 타입의 값을 자유롭게 할당할 수 있음

<div align="left">
# 데이터 타입

### 원시 타입 (Primitive Data Type)

데이터 타입은 한정된 메모리 공간을 효율적으로 사용하기 위해서 그리고 2진수 데이터로 메모리에 저장된 데이터를 다양한 형태로 사용하기 위해 존재함
총 7개의 데이터 타입이 있음

#### number

모든 수를 실수를 처리하며 정수만을 표현하기 위한 특별한 데이터 타입은 없음

```
var negative = -20;      // 음의 정수
var binary = 0b01000001; // 2진수
var octal = 0o101;       // 8진수
var hex = 0x41;          // 16진수
```

자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석됌

```
console.log(binary); // 65
console.log(octal);  // 65
console.log(hex);    // 65

console.log(binary === octal); // true
console.log(octal === hex);    // true
```

그리고 양의 무한대(Infinity), 음의 무한대(-Infinity), 산술 연산 불가(NaN(Not a number))도 표현할 수 있음

```
var pInf = 10 / 0;  // 양의 무한대
console.log(pInf);  // Infinity

var nInf = 10 / -0; // 음의 무한대
console.log(nInf);  // -Infinity

var nan = 1 * 'string'; // 산술 연산 불가
console.log(nan);       // NaN
```

#### string

텍스트 데이터를 나타낼 때 사용함
자바스크립트의 문자열은 **변경 불가능**함. 즉, 문자열이 생성되면 그 문자열을 변경할 수 없음을 말함

```
var str = "hi"
str = "hoho"
```

위의 예시에서 첫 번째 구문이 실행되면 메모리에 문자열 "hi"가 생성되고 식별자 str은 메모리에 생성된 문자열 "hi"의 메모리 주소를 가리킴
그 후 두 번째 구문이 실행되면 "hi"라는 문자열을 수정하는 것이 아니라 문자열 "hoho"를 다른 메모리에 생성하고 식별자 str은 문자열 "hoho"가 담긴 메모리를 가리킴
"hi"와 "hoho" 둘 다 메모리에 존재함 단지 변수 str이 가리키는 메모리가 달라졌을 뿐임

문자열은 배열처럼 인덱스를 통해 접근 가능함 == 유사 배열
이미 생성된 문자열의 일부분을 변경해도 반영되지 않음(에러가 발생하지는 않는다)
한 번 생성된 문자열은 read only(변경불가능)임
그러나 새로운 문자열을 재할당 하는 것은 가능함 왜냐하면 기존의 문자열을 변경하는 것이 아닌 새로운 문자열을 새로 할당하는 것이기 때문임

```
var str = "문자열이지롱"

// 이미 생성된 문자열의 일부분을 변경하는 것은 X
str[0] = "호"
console.log(str); // 문자열이지롱


// 새로운 문자열을 할당하는 것은 O

str = "무자열이지롱";
console.log(무자열이지롱)

str += " 되나?";
console.log(무자열이지롱 되나?)

```

#### boolean

불리언타입은 조건문에서 자주 사용됨
null, undefined, 숫자 0은 false로 간주됨

#### undefined

선언 이후 값을 할당하지 않은 변수는 undefined 값을 가짐
선언은 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 undefined가 리턴됨

이는 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태이기 때문에 자바스크립트 엔진이 undefined로 초기화하기 때문에 undefined를 리턴함
만약 변수의 값이 없다는 것을 명시하고 싶은 경우에는 undefined 대신 null을 할당함

#### null

null은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용함
이는 변수가 기억하는 메모리 어드레스의 참조 정보를 제거하는 것을 의미하며 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 가비지 콜렉션을 수행할 것임

함수가 호출되었으나 유효한 값을 반환할 수 없는 경우에도 명시적으로 null을 반환하기도 함

null의 타입을 알기 위해 typeof 연산자를 사용하면 null이 아니라 object가 나옴
이는 자바스크립트 설계상의 오류이므로 typeof대신 일치 연산자(===)를 사용해야함

#### symbol(ES6에서 추가)

이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용함
심볼은 symbol 함수를 호출해 생성함
이 때 생성된 심볼 값은 다른 값들과 다른 유일한 심볼값임

### 객체 타입(Object type, Reference type)

자바스크립트는 객체 기반의 스크립트 언어.
원시 타입을 제외한 나머지 값들은 모두 객체임
또한 객체는 pass-by-reference(참조에 의한 전달) 방식으로 전달됌

# 변수

데이터를 일정기간 동안 기억하여 필요한 때에 다시 사용하기 위해서 데이터에 고유 이름인 식별자를 명시한 것을 말함

var, let, const 키워드를 사용하여 **선언**하고 할당 연산자를 사용해 값을 **할당**함
그리고 식별자인 변수명을 통해 변수에 저장된 값을 **참조**한다

식별자는 데이터가 저장된 메모리 상의 주소를 기억한다. 따라서 식별자를 통해 메모리에 저장된 값을 참조할 수 있다. 또한 변수명을 통해 데이터의 의미를 명확히 할 수 있어 코드의 가독성이 좋아지는 효과도 있다.

### 변수의 선언

변수의 목적을 쉽게 이해할 수 있도록 변수명을 지정해야함
변수명은 **명명 규칙**이 존재함

- 반드시 영문자, 언더스코어(\_), 달러 기호($)로 시작해야함
- 자바스크립트는 대소문자 구별하므로 사용할 수 있는 문자는 "A"~"Z", "a"~"z"

변수를 선언할 때는 var, let, const의 키워드를 사용함
값을 할당하지 않은 변수(선언만 되어있는 변수)는 undefined로 초기값을 가짐

### 변수의 중복 선언

`var` 키워드로 선언한 변수는 중복 선언이 가능함(에러x)
하지만 가능하면 변수의 중복 선언은 하지 않는 것이 좋음음

### 동적 타이핑

자바스크립트는 동적타입 언어임. 즉, 변수의 타입지정없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결정된다는 뜻임
따라서 같은 변수에 여러 타입의 값을 할당할 수 있음. 이를 동적 타이핑이라고 함

```
var foo;

console.log(typeof foo);  // undefined

foo = null;
console.log(typeof foo);  // object

foo = {};
console.log(typeof foo);  // object

foo = 3;
console.log(typeof foo);  // number

foo = 3.14;
console.log(typeof foo);  // number

foo = 'Hi';
console.log(typeof foo);  // string

foo = true;
console.log(typeof foo);  // boolean
```

### 변수 호이스팅(Variable Hoisting)

**호이스팅**이란 var선언문이나 function 선언문 등 모든 선언문이 해당 스코프의 선두로 옮겨진 것처럼 동작하는 특성을 말함

변수는 아래와 같이 3단계에 걸쳐서 생성됨
|선언단계|변수객체에 변수 등록. 이 변수는 객체가 참조하는 대상이 됨|
|초기화 단계|변수 객체에 등록된 변수를 메모리에 할당. 이 단계에서 변수는 undefined로 초기화|
|할당단계|undefined로 초기화된 변수에 실제 값을 할당|

`var`로 선언된 변수는 선언단계와 초기화 단계가 한번에 이루어짐
(스코프에 변수 등록 + 변수는 메모리에 공간을 확보한 후 undefined로 초기화 된다는 뜻)
그래서 변수 선언문 이전에 변수에 접근해도 변수 객체에 변수가 존재하기 때문에 에러가 발생하지 않고 undefined를 리턴함
이런 현상을 호이스팅이라고 함

```
console.log(cat); //1, undefined
var cat = "rey"; // 2
console.log(cat) //3, rey

```

1번이 실행되기 전에 2번이 위로 끌어올려진 것처럼 호이스팅되어 1앞에 var cat이 옮겨짐
하지만 변수 선언 단계 & 초기화 단계가 할당단계와 따로 진행되기 때문에 cat에는 undefined가 할당되어있음
2에서 변수에 값이 할당되었기 때문에 rey가 출력됨

자바스크립트는 블록 레벨 스코프를 가지지 않고 함수 레벨 스코프를 가짐
단 ECMAScript 6에서 도입된 let, const 키워드를 사용하면 블록레벨 스코프를 사용할 수 있음

|함수레벨 스코프| 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 회부에서는 참조할 수 없다. 즉 함수 내부에서 선언한 변수는 지역변수, 함수 외부에서 선언한 변수는 전역변수|
|블록레벨 스코프| 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효. 코드 블록 외부에서 참조할 수 없음|

### var 키워드로 선언된 변수의 문제점

- 함수 레벨 스코프(Function-level scope)
   - 전역 변수의 남발
   - for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.

- var 키워드 생략 허용
   - 의도하지 않은 변수의 전역화

- 중복 선언 허용
   - 의도하지 않은 변수값 변경

- 변수 호이스팅
   - 변수를 선언하기 전에 참조가 가능하다.

전역 변수는 유효 스코프가 넓어서 어디에서 어떻게 사용될 지 파악하기 힘듦
이는 의도치 않은 변수의 변경이 발생할 수 있는 가능성이 증가함
또한 여러 함수와 상호 의존하는 등 사이드 이펙트가 있을 수 있어서 복잡성이 증가함
변수의 유효 스코프는 좁을수록 좋음
ES6는 이러한 `var`의 단점을 보완하기 위해 let과 const 키워드를 도입함
   </div>

# 표현신과 연산자

값은 당양한 방법(표현식)으로 생성할 수 있다.
표현식(expressio)은 리터럴, 식별자, 연산자, 함수 호출 등의 조합이다.표현식은 평가(evaluation)되어 하나의 값을 만든다.
**표현식은 하나의 값으로 평가될 수 있는 문(statement)이다.**

```javascript
//리터럴 표현식
10;

//식별자 표현식
sum;

//연산자 표현식
10 + 20;

//함수/메소드 표현식
square();
```

리터럴, 식별자, 연산자, 함수/메소드 표현식은 결국 평가되어 하나의 값이 되므로 값은 동등한 관계, 동치(equivalent)이다.
표현식은 **값처럼** 사용할 수 있고 이것은 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 의미이다.

```javascript
var x = 10;

//연산자 표현식
x + 30; //식별자 표현식과 숫자 리터럴과 연산자의 조합
```

- 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수 있다.

# 문과 표현식

문(statement)은 자바스크립트 엔진에게 내리는 명령이다.
변수 선언문을 실행하면 변수가 선어되고, 할당문을 실행하면 할당이 된다. 주어진 조건에 따라 코드 블록({...})이 실행이 결정되고, 반복문을 실행하면 코드 블록이 반복 실행된다.

```javascript
//변수 선언문
var x;

//할당문
x =5;

//함수 선언문
function foo (){}

//조건문
if(x>5){...}

//반복문
for(var i=0; i<10; i++>){...}
```

문은 리터럴, 연산자, 표현식, 키워드 등으로 구성되며 세미콜론(;)으로 끝나야한다. (코드블록{...}은 제외)

문의 끝에 붙이는 세미콜론은 옵션으로 쓰지 않아도 자바스크립트 엔진이 스크립트를 해석할 때, 문의 끝이라고 예측되는 지점에 자동으로 삽입(세미콜론 자동 삽입 기능, ASI, automatic semicolon insertion)해준다.

자바스크립트의 모든 코드는 문 또는 표현식이다. 문은 var, let, const, function, class와 같은 선언 키워드를 사용하여 변수나 함수를 생성하기도 하고 if, for, while 문과 같은 제어문을 생성하여 프로그램 흐름을 제어하기도 한다.

```javascript
//선언문(declaration statement)
let x = 5 * 10; //표현식 x = 5 * 10을 포함하는 문이다.

//할당문(assignment statement)
x = 100; //이 자체가 표현식이지만 완전한 문이기도 하다.
```

- 위의 선언문은 표현식이 아닌 문이다. 다시 말해 값으로 평가될 수 없고 선언문은 값처럼 사용할 수 없다.

```javascript
var foo = var x = 5 * 10;
```

할당문은 그 자체가 표현식이다.

# 연산자

연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만든다.

- 연산의 대상을 피연산자(operand)라 한다.
- 피연산자도 평가되어 하나의 값이기 때문에 표현식이고 피연산자를 연산자와 결합한 연산자 표현식도 또한 표현식이다.

```javascript
//산술 연산자
5 * 4; //20

//문자열 연결 연산자
"My name is" + "Lee"; //"My name is Lee"

//할당 연산자
var color = "red"; //"red"

//비교 연산자
3 >
  5(
    //false

    //논리 연산자
    5 > 3
  ) && 2 < 4; //ture

//타입 연산자
typeof "Hi"; //"string"
```

- 피연산자는 연산의 대상이 되어야 하므로 값을 평가할 수 있어야 한다.
- 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.

# 산술 연산자

산술 연산자(arithmetic operator)는 피연산자를 대상으로 수학적 곗ㄴ을 수행해 새로운 숫자 값을 만든다. 산술 연산을 할 수 없는 경우에는 NaN을 반환한다.

- 산술 연산자는 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.

## 이항 산술 연산자

이항 산술 연산자는 2개의 피연산자를 대상으로 연산하여 숫자 타입의 값을 만든다.

- 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과(side effect)가 없다.
- 피연산자의 값이 바뀌는 경우는 없고 새로운 값을 만든다.

```javascript
5 + 2; //7
5 - 2; //3
5 * 2; //10
5 / 2; //2.5
5 % 2; //1
```

## 단항 산술 연산자

단항 산술 연산자는 1개의 피연산자를 대상으로 연산한다.
증가/감소(++/-) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 다시 말해, 증가/감소 연사을 하면 피연산자의 값이 바뀐다.
|단항 산술 연산자|의미|
|--|--|
|++|증가|
|--|감소|
|+|어떠한 효과도 없다. 음수를 양수로 반전하지 않는다|
|-|양수를 음수로 음수를 양수로 반전한 값을 반환한다|
증가/감소(++/-) 연산자는 위치에 의미가 있다. 피연산자 앞에 위치한 전위 증가/감소 연산자(prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다. 피연산자 뒤에 위치한 후위 증가/감소 연산자(postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/갑소시킨다.

```javascript
var x = 5,
  result;

// 선대입 후증가(postfix increment operator)
result = x++;
console.log(result, x); //5 6

// 선증가 후대입 (prefix increment operator)
result = ++x;
console.log(result, x); //7 7

// 선대입 후감소(postfix decrement operator)
result = x--;
console.log(result, x); //7 6

// 선감소 후 대입(prefix decrement operator)
result = --x;
console.og(result, x); //5 5
```

`+` 단항 연산자는 피연산자에 어떠한 효과도 없고 음수를 양수로 반전하지도 않지만 **숫자 타입이 아닌** 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

```javascript
+10 + //10
  "10" + //10
  true + //1
  false; //0
```

`-` 단항 연산자는 피 연산자의 부호를 반전한 값을 반환한다. + 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

```javascript
-10 - //-10
  "10" - //10
  true - //-1
  false; //-0
```

## 문자열 연결 연산자

`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우에는 덧셈 연산자로 동작한다.

```javascript
//문자열 연결 연산자
"1" + "2"; // '12'
"1" + 2; // '12'

//산술 연산자
1 + 2; //3
1 + true; //2 (true ->1)
1 + false; //1 (false ->0)
true + false; // 1(true -> 1 / false -> 0)
1 + null; // 1(null->0)
1 + undefined; //Nan(undefined -> NaN)
```

# 할당 연산자

할당 연산자(assignment operator)는 우항에 있는 피연산자의 평가 결과를 자항에 있는 ㅎ변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 부수 효과가 있다.
|할당 연산자|사례|동일 표현|
|---|---|---|
|=|x = y|x = y|
|+ =|x + = y|x = x + y|
|- =|x - = y|x = x - y|
|_ =|x _ = y|x = x \* y|
|/ =|x / = y|x = x / y|
|% =|x % = y|x = x % y|

```javascript
var x;
x = 10; // 10
x += 5; // 15;
x = -5; // 10;
x *= 5; // 50;
x /= 5; // 10;
(x % / 5; /) / 0;
var str = "My name is";
str += "Lee"; //My name is Lee;
```

```javascript
var x;
console.log((x = 10)); //10
```

- 할당 연산은 변수에 값을 할당하는 부수효과만 있을 뿐 값으로 평가되지 않는것 처럼 보이지만 하나의 값으로 평가되는 표현식이다.
- 할당 연산 표현식을 다른 변수에 할당할 수도 있다.

```javascript
var x, y;
y = x = 10; //연쇄 할당(chained assignment)
console.log(x, y); //10 10
```

# 비교 연산자

비교 연산자(comparison operator)는 좌항과 우항의 피연산자를 비교하여 불리언 값을 반환한다. if문이나 for문과 같은 제어문의 조건식에서 주로 사용한다.

## 동등/일치 비교 연산자

| 비교 연산자 | 의미        | 사례  | 설명                     |
| ----------- | ----------- | ----- | ------------------------ |
| ==          | 동등 비교   | x==y  | x와 y의 값이 같음        |
| ===         | 일치 비교   | x===y | x와 y의 탸입이 같음      |
| !=          | 부등 비교   | x!=y  | x와 y의 값이 다름        |
| !==         | 불일치 비교 | x!==y | x와 y의 값고 타입이 다름 |

자바스크립트에 엔진에 의해 암묵적으로 타입이 자동 변환 되기도 하는 것을 \*암묵적 타입 변환\*\*이라 부른다.
동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.

- 동등 비교 연산자는 좌항과 우항의 피여산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값을 수 있으면 true를 반환한다.

```javascript
//동등 비교
5 == 5; //true
//타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 같은 값을 갖는다.
5 == "5"; //true
5 == 8; //false
```

- 비교 연산자는 편리한 경우도 있지만 부작용을 일으킬 수도 있기 때문에 사용하지 않는 것이 좋다.

```javascript
"" == "0"; //false
0 == ""; //true
0 == "0"; //true

false == "false"; //false
false == "0"; //true

false == undefined; //false
false == null; //false
null == undefined; //true
```

- 동등 비교 연산자는 예측하기 어려운 결과를 만들기도 하기 때문에, **일치 비교 연산자**를 사용하는 것이 좋다.

일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.

```javascript
//일치비교
5 === 5; //ture
5 === "5"; //false
```

일치 비교 연산자는 예측하기 쉽다. 일치 비교 연산자에서 주의할 것은 NaN이다.

```javascript
NaN === NaN; //false
```

- NaN은 자신과 일치하지 않는 유일한 값이다.
- 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용해야한다.

```javascript
isNaN(NaN); //true
```

- 숫자 0도 주의해야한다.

```javascript
// 부동등 비교
0 === -0; //true
```

```javascript
5 != 8; //true
5 != 5; //false
5 != "5"; //false

// 불일치 비교
5 !== 8; //ture
5 !== 5; //false
5 !== "5"; //ture
```

## 대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

```javascript
// 대소 관계 비교
5 > 0; // true
5 > 5; // false
5 > 8; // false

5 < 0; // false
5 < 5; // false
5 < 8; // true

5 >= 0; // true
5 >= 5; // true
5 >= 8; // false

5 <= 0; // false
5 <= 5; // true
5 <= 8; // true
```

# 삼항 조건 연산자

삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다.

- 자바스크립트의 유일한 삼항 연산자
- 부수 효과는 없다.

```
조건식 ? 조건식이 true 일때 반환할 값 : 조건식이 false일때 반환할 값
```

- 물음표(?) 앞의 첫번째 연산자가 조건식(불리언 타입의 값으로 평가될 표현식)
- 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환이 된다.
- 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환된다.
- 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다.

```javascript
var x = 2;

// x가 짝수이면 "짝수"를 홀수이면 "홀수"를 반환한다.
// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
var result = x % 2 ? "홀수" : "짝수";

console.log(result); //짝수
```

삼항 조건 연산자는 if...else 문을 사용해서 동일하게 처리할 수 있다.

```javascript
var x = 2,
  result;

// x가 짝수이면 '짝수'를 홀수이면 '홀수'를 반환한다.
// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
if (x % 2) result = "홀수";
else result = "짝수";

console.log(result); // 짝수
```

- if문은 표현식이 아닌 문이기 때문에 if..else문은 값으로 평가할 수 없다.
  삼항 조건 연산자 표현식은 값으로 평가할 수 잇는 식이다.

# 논리 연산자

논리 연산자(logical operator)는 우항과 자항의 피연산자를 논리 연산한다.

- 논리 부정(!)연산자는 언제나 **불리언** 값을 반환한다.
- 논리합(||) 연산자와 논리곱(&&) 연산자는 일반적으로 불리언 값을 반환하지만 반드시 불리언 값을 반환해야 하는 것은 아니다.

| 논리 연산자 | 의미        |
| ----------- | ----------- | --- | ---------- |
| (           |             | )   | 논리합(OR) |
| &&          | 논리곱(AND) |
| !           | 부정(NOT)   |

```javascript
//논리합(||)연산자
true || true; //true
true || false; //true
false || true; //true
false || false; //false

//논리곱(&&)연산자
true && true; //true
true && false; //false
false && true; //false
false && false; //false

//논리 부정(!) 연산자
!true; //false
!false; //true
```

논리 부정(!) 연산자는 항상 **불리언** 값을 반환한다.

- 피연산자는 암묵적 타입 변환이 되기 때문에 반드시 불리언 값일 필요는 없다.

```javascript
//암묵적 타입 변환
!0; //true
```

- 논리합(||) 연산자와 논리곱 (&&) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다.
- 두 연산자는 피연산자 중 어느 한쪽 값을 반환한다.

```javascript
//단축 평가
"cat" && "dog"; // "dog"
```

# 쉼표 연산자

쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```javascript
var x, y, z;
(x = 1), (y = 2), (z = 3); //3
```

# 그룹 연산자

그룹((...)) 연산자는 그룹 내의 표현식을 최우선으로 편가한다.

```javascript
10 * 2 + 3; // 23
10 * (2 + 3); // 50
```

# typeof 연산자

typeof 연산자는 자신의 뒤에 위치한 피연산자의 타입을 문자열로 반환한다.

- typeof 연산자는 7가지 문자열 중 하나를 반환한다.
- "null"을 반환하는 경우는 없고 함수의 경우 "function"을 반환한다.

```javascript
typeof ""; // "string"
typeof 1; // "number"
typeof NaN; // "number"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof Symbol(); // "symbol"
typeof null; // "object"
typeof []; // "object"
typeof {}; // "object"
typeof new Date(); // "object"
typeof /test/gi; // "object"
typeof function () {}; // "function"
```

- 자바스크립트 설계상의 오류로 null은 "object"로 반환한다.
- null 타입을 확인시에는 === 을 사용해야한다.

```javascript
typeof null // "object"

var foo = null;
console.log(tpyeof foo === null); // false
console.log(foo === null); // true
```

- 선언하지 않은 식별자를 typeof 연산자로 연산하면 ReferenceError가 발생하지 않고 "undefined"를 반환한다.

```javascript
typeof undeclared; // "undefined"
```

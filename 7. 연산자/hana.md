# 표현식과 연산자

표현식은 평가되어 하나의 값을 만든다<br>
즉, 표현식은 하나의 값으로 평가될 수 있는 statement(문)이며, 표현식과 값은 동등한 관계이다. 결과적으로 표현식은 값처럼 사용할 수 있다

```
var y = 5;

y + 1; // 식별자 표현식(var)과 숫자 리터럴(1)과 연산자(+)의 조합
```

# 문(statement)과 표현식

<p>문은 자바스크립트에게 내리는 명령이다. 즉 변수 선언문을 실행하면 변수가 실행되고, 조건문을 실행하면 조건에 따라 코드 블록 실행이 결정되는 등을 말한다</p>

<p>표현식과 문은 구별이 어려울 수 있다
표현식은 평가되어 값을 만들지만 그 이상은 할 수 없다
문은 선언 키워드를 사용하여 변수나 함수를 생성하기도 하고 제어문을 생성하여 프로그램의 흐름을 제어하기도 한다</p>

<p>표현식의 역할을 값을 생성하는 것이다
문의 역할은 표현식으로 생성한 값을 사용해 명령을 내리는 것이다
문에는 표현식은 문과 표현식이 아닌 문이 있다
예를 들어 선언문 값은 평가될 수 없다
하지만 할당문은 그 자체가 표현식이다
(아래 예시 참고)</p>

```
// 선언문
var x = 5 + 2; // 표현식 ㅌ = 5 + 2를 포함하는 문

// 할당문
x = 10 // 이 자체가 표현식이지만 완전한 문이기도 함

따라서 위의 예제에서 선언문은 표현식이 아닌 문이므로 값으로 평가될 수 없기에 값 처럼 사용할 수 없다

```

# 연산자란?

<p>하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만듦. 이 떄 연산의 대상을 피연산자라고 함<br>
피연산자도 평가되어 하나의 값이 되므로 표현식이고 피연산자를 연산자와 결합한 연산자의 표현식도 물론 표현식이다</p>

```
// 산술 연산자
5 * 2 // 10

// 문자열 연결 연산자
'my name is' + 'jeong' // 'my name is jeong'


// 할당 연산자

var color = "blue" // "blue"

// 비교 연산자

1 > 5 // false

// 논리 연산자
(5 > 2) && (8 < 10) // true

// 타입 연산자
typeof 'hi' // 'string'

```

# 산술 연산자

<p>피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듦.
산술 연산이 불가능한 경우 NaN 리턴함함</p>

### 이상 산술 연산자

<p>2개의 피연산자를 대상으로 연산하여 숫자 타입의 값을 만듦<br>
모든 이항 산술 연산자는 피연산자의 값을 변경하는 사이드 이펙트가 없음<br>
즉, 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없음</p>

| 이항 산술 연산자 | 의미   |
| ---------------- | ------ |
| +                | 덧셈   |
| -                | 뺄셈   |
| \*               | 곱셈   |
| /                | 나눗셈 |
| %                | 나머지 |

### 단항 산술 연산자

<p>1개의 피연산자를 대상으로 연산함<br>
증가/감소 연산을 하면 피연산자의 값이 바뀜</p>

| 단항 산술 연산자 | 의미                                          |
| ---------------- | --------------------------------------------- |
| ++               | 증가                                          |
| --               | 감소                                          |
| +                | 어떠한 효과x, 음수를 양수로 반전하지 x        |
| -                | 양수를 음수로, 음수를 양수로 반전한 값 리턴함 |

증가 감소 연산자는 위치에 따라 피연산자의 값이 다르게 나옴<br>
아래의 예시를 보자

```
var x = 5, result;

// 선대입 후증가
result = x++;
console.log(result, x); // 5 6

// 선증가 후대입
result = ++x;
console.log(result, x); // 7 7

// 선대입 후감소
result = x--;
console.log(result, x); // 7 6

// 선감소 후대입
result = --x;
console.log(result, x); // 5 5
```

<p> `+` 단항 연산자는 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자타입으로 변환하여 반환함<br>
이 때 피연산자 자체를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환함. 따라서 부수효과는x</p>

```
+10 // 10 // 숫자라서 타입 변경x
+'10' // 10 // 문자열10을 숫자 타입으로 변환
+true // 1, 자바스크립트 내부적으로 true를 숫자로 변환하면 1로 변환되게끔 정의되어 있음
+false // 0, 자바스크립트 내부적으로 false를 숫자로 변환하면 0으로 변환되게끔 정의되어 있음
```

<p>`-` 단항 연산자는 피연산자의 부호를 반전한 값을 반환함<br>
`+` 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환함<br>
이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환함 따라서 부수 효과는 x</p>

```
-10 // -10
-'10' // -10
-true // -1
-false // -0
```

### 문자열 연결 연산자

`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작함

```
// 문자열 연결 연산자
'1' + '3' = // '13'
'1' + 3 // '13'

// 산술 연산자
1 + 2          // 3
1 + true       // 2 (true -> 1)
1 + false      // 1 (false -> 0)
true + false    // 1 (true -> 1 / false → 0)
1 + null       // 1 (null -> 0)
1 + undefined // NaN (undefined -> NaN)

```

<p>자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 함<br>
위의 예시에 1 + true를 연산하니 자바스크립트 엔진이 자동으로 true를 1이라는 숫자타입으로 강제로 바꾸어 연산을 함<br>
이를 암묵적 타입변환 혹은 타입 강제 변환이라 함</p>

# 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당함<br>
좌항의 변수에 값을 할당하므로 사이드 이펙트가 있음

| 할당 연산자 | 사례    | 동일 표현  |
| ----------- | ------- | ---------- |
| =           | x = y   | x = y      |
| +=          | x += y  | x = x + y  |
| -=          | x -= y  | x = x - y  |
| \*=         | x \*= y | x = x \* y |
| /=          | x /= y  | x = x / y  |
| %=          | x %= y  | x = x % y  |

```
var x;

x = 10;   // 10
x += 5;   // x = x + 5, 15
x -= 5;   // x = x - 5, 10
x *= 5;   // x = x + 5, 50
x /= 5;   // x = x / 5, 10
x %= 5;   // x = x % 5, 0

var str = 'My name is ';
str += 'Lee'; //str = str + 'Lee', My name is Lee
```

할당 연산은 변수에 값을 할당하는 사이드 이펙트만 있을 뿐 하나의 값으로 평가되는 표현식임<br>
할당 표현식은 할당된 값으로 평가됨. 따라서 할당 표현식을 다른 변수에 할당할 수도 있음

```
var x, y;
y = x = 10; // 연쇄 할당(Chained assignment)
console.log(x, y); // 10 10
```

# 비교 연산자

좌항과 우항의 피연산자를 비교하여 불리언 값을 리턴함<br>
주로 if나 for문 같은 제어문의 조건식에서 주로 사용함

### 동등/일치 비교 연산자

| 비교 연산자 | 의미        | 사례    | 설명                     |
| ----------- | ----------- | ------- | ------------------------ |
| ==          | 동등 비교   | x == y  | x와 y의 값이 같음        |
| ===         | 일치 비교   | x === y | x와 y의 값과 타입이 같음 |
| !=          | 부등 비교   | x != y  | x와 y의 값이 다름        |
| !==         | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 |

동등 비교 연산자(==)는 좌항과 우항의 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값을 갖는지 비교함<br>
따라서 동등비교 연산자는 암묵적 타입 변환 후에 좌항과 우항이 같은 값을 가질 수 있으면 true반환함

```
// 동등 비교
5 == 5 // true
// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 같은 값을 가짐
5 == '5' //true
5 == 8 // false

```

하지만 동등 비교 연산자는 아래 예시와 같이 부작용을 일으키므로 사용하지 않는 것이 좋음

```
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

```

위와 같이 예측하기 어려운 결과를 내기 때문에 일치 비교 연산자(===)를 사용하자<br>

일치 비교 연산자는 좌항과 우항의 피연산자가 타입도 같도 값도 같은 경우에 한해 true반환함

```
// 일치 비교
5 === 5   // true
5 === '5' // false
```

단, 주의할 점은 NaN임<br>
NaN은 자신과 일치하지 않는 유일한 값임. 따라서 NaN가 숫자인지 아닌지 조사하려면 빌트인 함수인 isNaN을 사용해야함

```
NaN === NaN // false

isNaN(NaN) // true
```

숫자 0도 주의해야함

```
0 === -0 // true
```

### 대소 관계 비교 연산자

|대소 관계 비교 연산자|예제|설명|
|>|x > y|x가 y보다 크다|
|<|x < y|x가 y보다 작다|
|>=|x >= y|x가 y보다 같거나 크다|
|<=|x <= y|x가 y보다 같거나 크다|

```
5 > 0    // true
5 > 5    // false
5 > 8    // false

5 < 0    // false
5 < 5    // false
5 < 8    // true

5 >= 0   // true
5 >= 5   // true
5 >= 8   // false

5 <= 0   // false
5 <= 5   // true
5 <= 8   // true

```

# 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정함

> 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일 때 반환할 값

`예시`

```
var x = 2;

var result = x % 2 ? '홀수' : '짝수';

console.log(result) // 짝수
// 2 % 2 는 0이고 0은 false로 암묵적 타입 변환되므로 짝수라는 결과가 나옴

```

# 논리 연산자

|논리 연산자|의미|
|`||`|논리합(OR)|
|&&|논리곱(AND)|
|!|부정(NOT)|

`예시`

```
// 논리합(||) 연산자
true || true   // true
true || false  // true
false || true  // true
false || false // false

// 논리곱(&&) 연산자
true && true   // true
true && false  // false
false && true  // false
false && false // false

// 논리 부정(!) 연산자
!true  // false
!false // true
```

논리 부정 연산자(!)는 항상 불리언 값을 리턴함<br>
만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환이 됌

```
// 암묵적 타입 변환
!0 // true
```

하지만 논리합 연산자(`||`)나 논리곱(`&&`) 연산자의 연산 결과는 불리언 값이 아닐 수 있음<br>
이 두 개의 연산자는 항상 피연산자 중 어느 한 쪽 값을 반환함
(단축 평가 챕터에서 좀 더 자세히 다룰 예정)

# 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환함

```
var x, y, z;
x = 1, y = 2, z = 3; // 3
```

# 그룹 연산자

그룹 연산자((...))는 그룹 내의 표현식을 최우선으로 평가함<br>
그룹 연산자를 사용하면 연산자의 우선 순위를 1순위로 높일 수 있음

```
10 * 2 + 3   // 23
10 * (2 + 3) // 50
```

# typeof 연산자

typeof 연산자는 7가지 문자열 "string", "number", "boolean", "undefined", "symbol", "object", "function" 중 하나를 반환함<br>

"null"을 반환하는 경우는 없으며 함수의 경우 "function"을 반환함

```
typeof ''              // "string"
typeof 1               // "number"
typeof NaN             // "number"
typeof true            // "boolean"
typeof undefined       // "undefined"
typeof Symbol()        // "symbol"
typeof null            // "object"
typeof []              // "object"
typeof {}              // "object"
typeof new Date()      // "object"
typeof /test/gi        // "object"
typeof function () {}  // "function"
```

`주의점`

1. null
   typeof 연산자로 null을 연산하면 'object'를 반환함.
   이는 자바스크립트의 첫 번째 버전에서 이렇게 설계된 것을 현재의 버전에 반영하지 못하기 때문임.
   따라서 null의 타입을 확인할 때는 일치 연산자(==)를 사용해야함.

```
var foo = null;
console.log(typeof foo === null); // false, 왜냐하면 typeof null은 object로 반환되니까
console.log(foo === null);        // true
```

2. 선언하지 않은 식별자

선언하지 않은 식별자를 typeof 연산자로 연산하면 ReferenceError가 아니라 undefined를 반환함.

```
typeof undeclared  // "undefined"
```

<p>변수 호이스팅과 관련이 있음<br>
변수 호이스팅이란 자바스크립트 엔진이 코드를 해석할 때 해당 스코프 내에서 모든 변수 선언문을 먼저 처리해 메모리에 변수를 할당하고 undefined로 초기화하는 것을 말함<br>
따라서 자바스크립트에서는 선언하지 않은 식별자를 사용할 경우 해당 변수가 호이스팅되어서 undefined로 초기화 되어있기 때문에 undefined가 반환됨
이 때 변수가 아직 할당되어 있지 않기 때문에 ReferenceError가 발생하지 않고 undefined 값을 반환함</p>

<p>하지만 변수를 선언하지 않고 사용하는 것은 코드의 가독성을 저해하고 디버깅을 어렵게 만들기 때문에 변수를 선언하고 사용하자</p>
